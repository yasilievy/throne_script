import cv2, pytesseract, pyautogui, time, numpy as npfrom pynput.keyboard import Key, Listenerfrom pynput.mouse import Button, Controllerfrom os import listdirfrom os.path import isfile, joinpytesseract.pytesseract.tesseract_cmd = 'C:\\OCR\\tesseract.exe'def on_press(key):    print('{0}'.format(key))    # print(time.time()-time_start)    # print('{0} pressed'.format(    #     key))    # key_log.write('{0} pressed'.format(key) + ',' + str(time.time() - time_start) + '\n')    # if 'f1' in '{0} pressed'.format(key):    #     pyautogui.typewrite('/target Zennar')    #     time.sleep(0.2)    #     pyautogui.press('enter')    #     time.sleep(0.2)    #     pyautogui.press('f2')    #     time.sleep(0.35)    #     pyautogui.press('f3')    # if '`' in '{0} pressed'.format(key):    #     pyautogui.typewrite('/target Zennar')    #     pyautogui.press('f4')def on_release(key):    # print(time.time()-time_start)    print('{0} release'.format(        key))    # key_log.write('{0} released'.format(key) + ',' + str(time.time() - time_start) + '\n')    if key == Key.esc:        # key_log.close()        # Stop listener        return False# def on_press_screen_read(key):#     if '{0}'.format(key) == 'f2':def text_read():    temp_time = time.time()    # if '{0}'.format(key) == 'f2':    loc = "ss\\"    # name = "img" + str(no) + ".png"    name = "img_shot.png"    ss = pyautogui.screenshot()    # print(f'screenshot {time.time() - temp_time}')    img = cv2.cvtColor(np.array(ss), cv2.COLOR_RGB2BGR)    # ss.save(loc + name)    # print(f'saved image {time.time() - temp_time}')    # # Read image from which text needs to be extracted    # img = cv2.imread(loc + name)    # print(f'img read image {time.time() - temp_time}')    # cropping definition    chat_box_x1 = 25    # chat_box_y1 = 410    chat_box_y1 = 690    chat_box_x2 = 340    chat_box_y2 = 859    target_box_x1 = 360    target_box_y1 = 725    target_box_x2 = 480    target_box_y2 = 740    target_health_x1 = 361    target_health_y1 = 743    target_health_x2 = 492    # target_health_y2 = 747    target_health_y2 = 744    # crop    # img = img[chat_box_y1:chat_box_y2, chat_box_x1:chat_box_x2]    img = img[target_box_y1:target_box_y2, target_box_x1:target_box_x2]    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    ret, thresh1 = cv2.threshold(gray, 0, 255, cv2.THRESH_OTSU | cv2.THRESH_BINARY_INV)    # cv2.imwrite(loc + "threshold" + name, thresh1)    # Specify structure shape and kernel size.    # Kernel size increases or decreases the area    # of the rectangle to be detected.    # A smaller value like (10, 10) will detect    # each word instead of a sentence.    # rect_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (10, 10))    # print(f'rect_kernel {time.time() - temp_time}')    # dilation = cv2.dilate(thresh1, rect_kernel, iterations = 1)    contours, hierarchy = cv2.findContours(thresh1, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)    im2 = img.copy()    text = ""    # print(f'before contours {time.time() - temp_time}')    for cnt in contours:        x, y, w, h = cv2.boundingRect(cnt)        # Drawing a rectangle on copied image        rect = cv2.rectangle(im2, (x, y), (x + w, y + h), (0, 255, 0), 2)        # Cropping the text block for giving input to OCR        cropped = im2[y:y + h, x:x + w]        # Open the file in append mode        # file = open("recognized.txt", "w+")        # Apply OCR on the cropped image        text = pytesseract.image_to_string(cropped)        # print(text)    # print(f'after contours {time.time() - temp_time}')    return(text)def party_member_read():    temp_time = time.time()    loc = "ss\\"    # name = "img" + str(no) + ".png"    name = "img_shot.png"    ss = pyautogui.screenshot()    img = cv2.cvtColor(np.array(ss), cv2.COLOR_RGB2BGR)    party_box_x1 = 1061    party_box_y1 = 493    party_box_x2 = 1197    party_box_y2 = 627    img = img[party_box_y1:party_box_y2, party_box_x1:party_box_x2]    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    ret, thresh1 = cv2.threshold(gray, 0, 255, cv2.THRESH_OTSU | cv2.THRESH_BINARY_INV)    contours, hierarchy = cv2.findContours(thresh1, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)    im2 = img.copy()    text = ""    for cnt in contours:        x, y, w, h = cv2.boundingRect(cnt)        rect = cv2.rectangle(im2, (x, y), (x + w, y + h), (0, 255, 0), 2)        cropped = im2[y:y + h, x:x + w]        text = pytesseract.image_to_string(cropped)    return textdef is_target_dead():    # temp_time = time.time()    loc = "ss\\"    name = "img_shot.png"    ss = pyautogui.screenshot()    img = cv2.cvtColor(np.array(ss), cv2.COLOR_RGB2BGR)    target_health_x1 = 362    target_health_y1 = 745    target_health_x2 = 490    target_health_y2 = 746    img = img[target_health_y1:target_health_y2, target_health_x1:target_health_x2]    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    cv2.imwrite(loc + "gray" + name, gray)    print(gray[0][127])    # print(len(gray[0][65:]))    one_per = gray[0][1]    thirty_per = gray[0][30]    fifty_per = gray[0][63]    hundred_per = gray[0][127]    # return [one_per,fifty_per,hundred_per]    return [one_per,thirty_per,fifty_per,hundred_per]def eo_target():    temp_time = time.time()    loc = "ss\\"    name = "img_shot.png"    ss = pyautogui.screenshot()    img = cv2.cvtColor(np.array(ss), cv2.COLOR_RGB2BGR)    target_health_x1 = 362    target_health_y1 = 745    target_health_x2 = 490    target_health_y2 = 746    self_health_x1 = 890    self_health_y1 = 535    self_health_x2 = 891    self_health_y2 = 536    self_mana_x1 = 650    self_mana_y1 = 551    self_mana_x2 = 940    self_mana_y2 = 552    img1 = img[target_health_y1:target_health_y2, target_health_x1:target_health_x2]    img2 = img[self_health_y1:self_health_y2, self_health_x1:self_health_x2]    img3 = img[self_mana_y1:self_mana_y2, self_mana_x1:self_mana_x2]    gray = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)    gray2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)    gray3 = cv2.cvtColor(img3, cv2.COLOR_BGR2GRAY)    # print(gray2[0][0])    # print(len(gray[0][65:]))    one_per = gray[0][1]    thirty_per = gray[0][50]    fifty_per = gray[0][63]    hundred_per = gray[0][127]    myhealth = gray2[0][0]    mymanalow = gray3[0][0]    mymanahi = gray3[0][280]    print(f'mana low: {mymanalow}')    print(f'mana hi: {mymanahi}')    print(f'health:{myhealth}')    # return [one_per,fifty_per,hundred_per]    # print(time.time()-temp_time)    return [one_per,thirty_per,fifty_per,hundred_per,myhealth,mymanalow,mymanahi]while True:    user_option = input('what to do:\n'                        '0 test\n'                        '1 collect\n'                        '2 run\n'                        '3 \n'                        '4 solo\n'                        '5\n')    # user_option = ('3'    #                '')    mouse = Controller()    if user_option == '0':        while True:            pyautogui.hotkey('alt', 'tab')            mouse.position = (1119,505)            mouse.click(Button.right)            mouse.click(Button.right)            # pyautogui.rightClick(1119,505)            input()    if user_option == '33':        pyautogui.hotkey('alt','tab')        with Listener(                on_press=on_press,                on_release=on_release) as listener:            listener.join()        while True:            mouse.position = (1119, 505)            mouse.click(Button.right)            mouse.click(Button.right)            time.sleep(0.5)    if user_option == '4':        while True:            if is_target_dead()[0]==45:                pyautogui.press('f5')                pyautogui.press('f5')            else:                pyautogui.press('f4')            time.sleep(1)    if user_option == '3':        # target_assist_one = 'lix'        target_assist_one = 'taylorwish'        pyautogui.hotkey('alt', 'tab')        follow_after_dead_bool = True        mana_filled = True        while True:            # print(f'mana status: high = {mana_filled}')            pyautogui.typewrite('/target ' + target_assist_one)            pyautogui.press('enter')            time.sleep(0.3)            if follow_after_dead_bool:                pyautogui.typewrite('/target ' + target_assist_one)                pyautogui.press('enter')                follow_after_dead_bool = False            pyautogui.press('f2')            time.sleep(0.3)            dead_health, third_health, half_health, full_health,my_health,my_mana_low, my_mana_hi= eo_target()            # if my_mana_low != 99:            #     print('switched to recovery mode')            #     mana_filled = False            # if not mana_filled:            #     if my_mana_hi == 99:            #         print('switched to use mana')            #         mana_filled = True            # if dead_health == 113:            #     if full_health == 113:            #         follow_after_dead_bool = True            #     else:            #         # if 'misery' in text_read().lower() or 'cave' in text_read().lower():            #         #     if half_health == 113:            #         #         pyautogui.press('f3')            #         #         pyautogui.press('f8')            #         #     else:            #         #            #         #         pyautogui.press('f8')            #         # else:            #         if half_health == 113:            #             if mana_filled:            #                 pyautogui.press('f3')            #             pyautogui.press('f8')            #         else:            #             pyautogui.press('f8')            #            #            # # if dead_health == 113:            # #     if half_health == 113:            # #         pyautogui.press('f3')            # #         pyautogui.press('f8')            # #     else:            # #            # #         pyautogui.press('f8')            #            # else:            #     follow_after_dead_bool = True            #     pyautogui.press('f6')            # if my_health != 62:            #     pyautogui.press('f9')            #            # else:            #     if dead_health == 113:            #         if full_health == 113:            #             pass            #         else:            #             pyautogui.press('f8')            #            ###########################            # if 'misery' in text_read().lower():            #     if dead_health == 113:            #         if full_health == 113:            #             follow_after_dead_bool = True            #         else:            #             if half_health == 113:            #                 pyautogui.press('f3')            #                 # pyautogui.press('f8')            #                 pyautogui.press('f4')            #             else:            #                 # pyautogui.press('f8')            #                 pyautogui.press('f4')            #     else:            #         follow_after_dead_bool = True            # else:            #     if dead_health == 113:            #         if full_healt `h == 113:            #             follow_after_dead_bool = True            #         else:            #             # pyautogui.press('f8')            #             pyautogui.press('f4')            #     else:            #         follow_after_dead_bool = True            ###############################            if 'misery' in text_read().lower():                if dead_health == 113:                    if half_health == 113:                        pyautogui.press('f3')                        pyautogui.press('f4')                    else:                        pyautogui.press('f4')                else:                    pyautogui.press('f5')                    follow_after_dead_bool = True            else:                if dead_health == 113:                        pyautogui.press('f4')                else:                    pyautogui.press('f5')                    follow_after_dead_bool = True            time.sleep(0.2)    if user_option == '5':        target_assist_one = 'valentintin'        pyautogui.hotkey('alt','tab')        ps_counter = 0        follow_after_dead_bool = True        idle_counter = 0        alter_assist = True        while True:            pyautogui.typewrite('/target ' + target_assist_one)            pyautogui.press('enter')            if follow_after_dead_bool:                pyautogui.typewrite('/target ' + target_assist_one)                pyautogui.press('enter')                follow_after_dead_bool = False            time.sleep(0.3)            pyautogui.press('f2')            time.sleep(0.3)            dead_health, half_health, full_health = is_target_dead()            if dead_health == 113:                if half_health == 113:                    pyautogui.press('f3')                # pyautogui.press('f3')                pyautogui.press('f4')            else:                follow_after_dead_bool = True            time.sleep(0.3)    if user_option == '1':        time.sleep(1)        pyautogui.hotkey('alt','tab')        pyautogui.keyDown('up')        time_lapse = 0        time_start = time.time()        key_log_string = ''        key_log = open('key_log.txt','a')        # Collect events until released        with Listener(                on_press=on_press,                on_release=on_release) as listener:            listener.join()    if user_option == '2':        pressed_key_list = []        time_log_list = []        time_diff_list = []        walk_scripts = [f for f in listdir('walk_scripts/') if isfile(join('walk_scripts/', f))]        print(walk_scripts)        walk_scripts_indexes = []        c1 = 1        for w_s in walk_scripts:            print(str(c1) + ' ' + w_s)            c1+=1        while True:            w_s_input = input('what script to run\n')            if w_s_input.isnumeric:                break            else:                print('enter valid number\n')        w_s_select = walk_scripts[int(w_s_input)-1]        open_key_log = open('walk_scripts//'+ w_s_select,'r')        # open_key_log = open('key_log de to temple 2.txt','r')        # open_key_log = open('key_log temple to de.txt','r')        open_key_log_split = open_key_log.read().replace('Key.','').split('\n')        open_key_log.close()        # start_pressed, start_time = open_key_log_split[0].split(',')        start_pressed = ''        start_time = 0        # time_log_list.append(start_time)        # time_diff_list.append(start_time)        # print(start_pressed + ' ' + start_time)        time.sleep(1)        # pyautogui.hotkey('alt','tab')        # pyautogui.keyDown('up')        start_boo = True        time_diff_holder = 0        pressed_key_temp = ''        for k_l in open_key_log_split:            pressed_key, time_log = k_l.split(',')            print(pressed_key)            print(pressed_key_temp)            if start_boo:                pressed_key_list.append('up pressed')                time_log_list.append(round(float(time_log) - float(start_time),5))                start_boo = False                start_pressed = pressed_key                start_time = time_log                pressed_key_list.append(pressed_key)                # pressed_key_list.append('up pressed')                # time_log_list.append(start_time)            else:                if pressed_key == start_pressed:                    time_diff_holder += round(float(time_log) - float(start_time),5)                    start_time = time_log                elif 'released' in pressed_key or 'esc' in pressed_key:                    time_diff_holder += round(float(time_log) - float(start_time),5)                    start_time = time_log                    time_log_list.append(time_diff_holder)                    time_diff_holder=0                    start_pressed = ''                    start_boo = True        input()        pyautogui.hotkey('alt','tab')        pyautogui.keyDown('up')        start_timer =time.time()        for i in range(0,len(pressed_key_list),1):            if 'up' in pressed_key_list[i]:                print(f'{pressed_key_list[i]} - {time_log_list[i]} time elapsed: {time.time() - start_timer}')  # {time_diff_list[i]}')                time.sleep(time_log_list[i])                print(f'{pressed_key_list[i]} - {time_log_list[i]} time elapsed: {time.time() - start_timer}')  # {time_diff_list[i]}')            elif 'esc' in pressed_key_list[i]:                pyautogui.keyUp('up')            else:                key_to_press = pressed_key_list[i].split(' ')[0]                temp_time = time.time()                print(f'{pressed_key_list[i]} - {time_log_list[i]} time elapsed: {temp_time - start_timer}')  # {time_diff_list[i]}')                pyautogui.keyDown(key_to_press)                if time_log_list[i] >0.07:                    time.sleep(time_log_list[i]-0.07)                else:                    time.sleep(time_log_list[i])                pyautogui.keyUp(key_to_press)                print(f'{time.time()-temp_time} total time keyDown')# time.sleep(1)# print(pyautogui.position())# pyautogui.hotkey('alt','tab')# pyautogui.keyDown('up')# # Collect events until released# with keyboard.Listener(on_press=on_press, on_release=on_release) as listener:#     listener.join()# pyautogui.typewrite('/stand')# pyautogui.hotkey('enter')## text_log = open('text_log.text','w')# time_start = time.time()# while True:#     if keyboard.is_pressed('left'):#         delta_time = round(time.time()-time_start,2)#         text_log.write(f'left,{delta_time}\n')#         time_start = time.time()#         print('left key pressed, time elapsed since last key: ' + str(delta_time))#         time.sleep(1)##     if keyboard.is_pressed('right'):#         delta_time = round(time.time()-time_start,2)#         text_log.write(f'right,{delta_time}\n')#         print('left right pressed, time elapsed since last key: ' + str(delta_time))#         time_start = time.time()#         time.sleep(1)# pyautogui.doubleClick(x=1138, y=789)# pyautogui.doubleClick(x=1138, y=789)## pyautogui.doubleClick(x=1138, y=789)# pyautogui.doubleClick(x=1138, y=789)# pyautogui.doubleClick(x=968, y=751)# pyautogui.press('f4')